import path from "node:path";
import fs from "fs-extra";
import { AiService } from "./ai-service.js";
import { GitService } from "./git-service.js";
import { CliError, asErrorMessage } from "../utils/errors.js";

const HOOK_FILE_NAME = "commit-msg";
const HOOK_MARKER = "# Generated by scafkit";

function buildHookScript(): string {
  return `#!/usr/bin/env sh
${HOOK_MARKER}
if command -v scafkit >/dev/null 2>&1; then
  scafkit hook run-commit-msg "$1" || true
else
  echo "[scafkit] 未找到 scafkit 命令，跳过 AI 提交信息生成"
fi
exit 0
`;
}

export interface HookStatus {
  installed: boolean;
  path: string;
  managedByScafkit: boolean;
}

export interface HookRunResult {
  updated: boolean;
  message?: string;
  warning?: string;
}

export class HookService {
  constructor(
    private readonly gitService = new GitService(),
    private readonly aiService = new AiService()
  ) {}

  private async getHookFilePath(): Promise<string> {
    const hooksDir = (await this.gitService.raw(["rev-parse", "--git-path", "hooks"])).trim();
    if (!hooksDir) {
      throw new CliError("无法定位 git hooks 目录");
    }
    const repoRoot = await this.gitService.getRepoRoot();
    const absoluteHooksDir = path.isAbsolute(hooksDir) ? hooksDir : path.join(repoRoot, hooksDir);
    return path.join(absoluteHooksDir, HOOK_FILE_NAME);
  }

  async status(): Promise<HookStatus> {
    const filePath = await this.getHookFilePath();
    const exists = await fs.pathExists(filePath);
    if (!exists) {
      return {
        installed: false,
        path: filePath,
        managedByScafkit: false
      };
    }
    const content = await fs.readFile(filePath, "utf-8");
    return {
      installed: true,
      path: filePath,
      managedByScafkit: content.includes(HOOK_MARKER)
    };
  }

  async install(): Promise<HookStatus> {
    const filePath = await this.getHookFilePath();
    await fs.ensureDir(path.dirname(filePath));
    await fs.writeFile(filePath, buildHookScript(), { mode: 0o755 });
    await fs.chmod(filePath, 0o755);
    return this.status();
  }

  async uninstall(): Promise<void> {
    const status = await this.status();
    if (!status.installed) {
      return;
    }
    if (!status.managedByScafkit) {
      throw new CliError("commit-msg hook 存在，但不是 scafkit 生成，已拒绝删除");
    }
    await fs.remove(status.path);
  }

  async runCommitMsgHook(messageFile: string): Promise<HookRunResult> {
    const hasStaged = await this.gitService.hasStagedChanges();
    if (!hasStaged) {
      return { updated: false, warning: "没有 staged 变更，跳过自动提交信息生成" };
    }

    const diff = await this.gitService.getStagedDiff();
    if (!diff.trim()) {
      return { updated: false, warning: "staged diff 为空，跳过自动提交信息生成" };
    }

    try {
      const message = await this.aiService.generateCommitMessage(diff);
      await fs.writeFile(messageFile, `${message}\n`, "utf-8");
      return { updated: true, message };
    } catch (error) {
      return {
        updated: false,
        warning: `AI 生成失败（不阻塞提交）: ${asErrorMessage(error)}`
      };
    }
  }
}
